#version 130
uniform float iTexSize;
uniform float iBlockOffset;
uniform float iSampleRate;

const float PI = radians(180.);
const float TAU = 2.*PI;
float clip(float a) { return clamp(a,-1.,1.); }
float smstep(float a, float b, float x) {return smoothstep(a, b, clamp(x, a, b));}
float theta(float x) { return smstep(0.,1e-3,x); }
float _sin(float a) { return sin(TAU * mod(a,1.)); }
float _sin_(float a, float p) { return sin(TAU * mod(a,1.) + p); }
float _tri(float a) { return (4.*abs(fract(a)-.5) - 1.); }
float freqC1(float note){ return 32.7 * exp2(note/12.); }
float minus1hochN(int n) { return (1. - 2.*float(n % 2)); }
float minus1hochNminus1halbe(int n) { return sin(.5*PI*float(n)); }
float fhelp(float x) { return 1. + .333*x; } // 1. + .33333*x + .1*x*x + .02381*x*x*x + .00463*x*x*x*x;
float linmix(float x, float a, float b, float y0, float y1) { return mix(y0,y1,clamp(a*x+b,0.,1.)); }
float s_moothmin(float a, float k) {
    float ha = max(1.-2.*abs(abs(a)-1.), 0.);
    return a >= 0. ? min(a, 1.) - .5/6.*ha*ha*ha : max(a, -1.) + .5/6.*ha*ha*ha;
}
float s_moothmin(float a) { return s_moothmin(a,.5); }

#define SONGLENGTH 34.186
#define NTIME 2
const float pos_B[2] = float[2](0.,24.);
const float pos_t[2] = float[2](0.,33.4884);
const float pos_BPS[1] = float[1](.7167);
const float pos_SPB[1] = float[1](1.3953);
float BPS, SPB, BT;

float Tsample;

#define filterthreshold 1.e-3

const float sequence_texture[700] = float[700](0.,2.,5.,29.,35.,.7001953125,1.,.1500244140625,.5,0.,0.,.08001708984375,.125,8.,16.,0.,8.,16.,16.,24.,8.,16.,24.,1.,2.,0.,0.,0.,24.,12.,-12.,-12.,-12.,0.,26.,59.,93.,0.,.333251953125,.66650390625,1.,1.3330078125,1.6669921875,2.,2.5,2.666015625,3.,3.5,3.666015625,4.,4.33203125,4.66796875,5.,5.33203125,5.5,5.66796875,5.83203125,6.,6.5,6.66796875,7.,7.33203125,7.66796875,0.,.333251953125,.66650390625,1.,1.3330078125,1.6669921875,2.,2.333984375,2.666015625,3.,3.333984375,3.666015625,4.,4.,4.33203125,4.66796875,4.83203125,5.,5.33203125,5.66796875,5.83203125,6.,6.,6.33203125,6.33203125,6.66796875,6.66796875,7.,7.,7.33203125,7.33203125,7.66796875,7.66796875,0.,.333251953125,.66650390625,1.,1.3330078125,1.6669921875,2.,2.333984375,2.666015625,3.,3.333984375,3.666015625,4.,4.,4.33203125,4.66796875,4.83203125,5.,5.33203125,5.33203125,5.66796875,5.83203125,6.,6.,6.33203125,6.33203125,6.66796875,6.66796875,7.,7.,7.33203125,7.33203125,7.66796875,7.66796875,.333251953125,.66650390625,1.,1.3330078125,1.6669921875,2.,2.5,2.666015625,3.,3.5,3.666015625,4.,4.33203125,4.66796875,5.,5.33203125,5.5,5.66796875,5.83203125,6.,6.5,6.66796875,7.,8.,8.,8.,1.,1.3330078125,1.6669921875,2.,2.333984375,2.666015625,3.333984375,3.333984375,3.666015625,4.,4.33203125,4.66796875,5.,5.,5.33203125,5.66796875,5.83203125,6.,6.33203125,6.66796875,6.72265625,6.33203125,7.,6.66796875,7.33203125,7.,7.66796875,7.33203125,8.,7.66796875,7.72265625,8.,8.,1.,1.3330078125,1.6669921875,2.,2.333984375,2.666015625,3.333984375,3.333984375,3.666015625,4.,4.33203125,4.66796875,5.,5.,5.33203125,5.66796875,5.83203125,6.,6.33203125,6.33203125,6.66796875,6.72265625,6.33203125,7.,6.66796875,7.33203125,7.,7.66796875,7.33203125,8.,7.66796875,7.72265625,8.,8.,24.,24.,24.,22.,24.,27.,17.,17.,17.,20.,24.,22.,24.,24.,26.,27.,19.,20.,24.,31.,29.,27.,26.,22.,29.,38.,24.,31.,39.,22.,31.,39.,21.,29.,36.,39.,20.,38.,12.,36.,31.,39.,43.,35.,31.,39.,43.,27.,51.,26.,50.,24.,48.,19.,43.,27.,39.,26.,38.,24.,31.,39.,22.,31.,39.,21.,29.,36.,39.,20.,38.,12.,36.,31.,39.,43.,47.,31.,50.,43.,43.,27.,46.,26.,47.,24.,43.,19.,41.,27.,38.,26.,35.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,11.,7.80078125,12.703125,7.3984375,5.6015625,12.1015625,8.6015625,14.5,11.703125,13.5,11.6015625,8.5,10.5,7.80078125,10.8984375,13.3984375,8.5,12.796875,7.80078125,10.1015625,6.,8.5,11.,8.8984375,13.796875,14.1015625,12.,12.203125,14.6015625,5.1015625,12.8984375,7.6015625,7.,11.,7.80078125,12.703125,7.3984375,5.6015625,12.1015625,8.6015625,14.5,11.703125,13.5,11.6015625,8.5,10.5,7.80078125,10.8984375,13.3984375,8.5,12.796875,7.80078125,12.796875,10.1015625,6.,8.5,11.,8.8984375,13.796875,14.1015625,12.,12.203125,14.6015625,5.1015625,12.8984375,7.6015625,7.,0.,0.,0.,0.,0.,0.,1.,0.,0.,0.,0.,0.);


float env_AHDSRexp(float x, float L, float A, float H, float D, float S, float R)
{
    float att = pow(x/A,8.);
    float dec = S + (1.-S) * exp(-(x-H-A)/D);
    float rel = (x <= L-R) ? 1. : pow((L-x)/R,4.);
    return (x < A ? att : x < A+H ? 1. : dec) * rel;
}

float sinshape(float x, float amt, float parts)
{
    return (1.-amt) * x + amt * sign(x) * 0.5 * (1. - cos(parts*PI*x));
}

float comp_SAW(int N, float inv_N, float PW) {return inv_N * (1. - _sin(float(N)*PW));}
float comp_TRI(int N, float inv_N, float PW) {return N % 2 == 0 ? .1 * inv_N * _sin(float(N)*PW) : inv_N * inv_N * (1. - _sin(float(N)*PW));}
float comp_SQU(int N, float inv_N, float PW) {return inv_N * (minus1hochN(N) * _sin(.5*float(N)*PW + .25) - 1.);}
float comp_HAE(int N, float inv_N, float PW) {return N % 2 == 0 ? 0. : inv_N * (1. - minus1hochNminus1halbe(N))*_sin(PW);}
float comp_OBO(int N, float inv_N, float PW) {return sqrt(inv_N) * (1. + _sin(float(N)*(1.5+PW)+.5*PI));}

float MADD(float t, float f, float p0, int NMAX, int NINC, float MIX, float CO, float NDECAY, float RES, float RES_Q, float DET, float PW, float LOWCUT, float keyF)
{
    float ret = 0.;
    float f_ = keyF > .99 ? 1. : (keyF < 1.e-3 ? f : pow(f, 1.-keyF));
    float INR = f_/CO;
    float IRESQ = 1./(RES_Q*f_);

    float p = f*t;
    float float_N, inv_N, comp_mix, filter_N;
    for(int N = 1 + int(LOWCUT/f - 1.e-3); N<=NMAX; N+=NINC)
    {
        float_N = float(N);
        inv_N = 1./float_N;
        comp_mix = MIX < -1. ? (MIX+2.) * comp_SAW(N,inv_N,PW)  - (MIX+1.) * comp_OBO(N,inv_N,PW)
                 : MIX <  0. ? (MIX+1.) * comp_TRI(N,inv_N,PW)  -     MIX  * comp_SAW(N,inv_N,PW)
                 : MIX < 1. ? (1.-MIX) * comp_TRI(N,inv_N,PW)  +     MIX  * comp_SQU(N,inv_N,PW)
                            : (MIX-1.) * comp_HAE(N,inv_N,PW)  + (2.-MIX) * comp_SQU(N,inv_N,PW);

        if(abs(comp_mix) < 1e-4) continue;

        filter_N = pow(1. + pow(float_N*INR,NDECAY),-.5) + RES * exp(-pow((float_N*f-CO)*IRESQ,2.));

        ret += comp_mix * filter_N * (_sin_(float_N * p, p0) + _sin_(float_N * p * (1.+DET), p0));
    }
    return s_moothmin(ret);
}

float MADD(float t, float f, float p0, int NMAX, int NINC, float MIX, float CO, float NDECAY, float RES, float RES_Q, float DET, float PW, int keyF)
{
    return MADD(t, f, p0, NMAX, NINC, MIX, CO, NDECAY, RES, RES_Q, DET, PW, 0., keyF);
}

float bracepad_cutoff(float B)
{
    return B<0 ? 0. : (B>=0. && B<8.) ? linmix(B, .125, 0., 0.0, 1.0) : 1.;
}
float bracepad_sub(float B)
{
    return B<0 ? 0. : (B>=12. && B<16.) ? linmix(B, .25, -3., 0.0, 1.0) : (B>=16. && B<24.) ? 1. : 0.;
}

float rfloat(int off){return sequence_texture[off];}

#define NTRK 2
#define NMOD 5
#define NPTN 3
#define NNOT 93
#define NDRM 11

int trk_sep(int index)      {return int(rfloat(index));}
int trk_syn(int index)      {return int(rfloat(index+1+1*NTRK));}
float trk_norm(int index)   {return     rfloat(index+1+2*NTRK);}
float trk_rel(int index)    {return     rfloat(index+1+3*NTRK);}
float trk_pre(int index)    {return     rfloat(index+1+4*NTRK);}
float trk_slide(int index)  {return     rfloat(index+1+5*NTRK);} // idea for future: change to individual note_slide_time
float mod_on(int index)     {return     rfloat(index+1+6*NTRK);}
float mod_off(int index)    {return     rfloat(index+1+6*NTRK+1*NMOD);}
int mod_ptn(int index)      {return int(rfloat(index+1+6*NTRK+2*NMOD));}
float mod_transp(int index) {return     rfloat(index+1+6*NTRK+3*NMOD);}
int ptn_sep(int index)      {return int(rfloat(index+1+6*NTRK+4*NMOD));}
float note_on(int index)    {return     rfloat(index+2+6*NTRK+4*NMOD+NPTN);}
float note_off(int index)   {return     rfloat(index+2+6*NTRK+4*NMOD+NPTN+1*NNOT);}
float note_pitch(int index) {return     rfloat(index+2+6*NTRK+4*NMOD+NPTN+2*NNOT);}
float note_pan(int index)   {return     rfloat(index+2+6*NTRK+4*NMOD+NPTN+3*NNOT);}
float note_vel(int index)   {return     rfloat(index+2+6*NTRK+4*NMOD+NPTN+4*NNOT);}
float note_slide(int index) {return     rfloat(index+2+6*NTRK+4*NMOD+NPTN+5*NNOT);}
float note_aux(int index)   {return     rfloat(index+2+6*NTRK+4*NMOD+NPTN+6*NNOT);}
float drum_rel(int index)   {return     rfloat(index+2+6*NTRK+4*NMOD+NPTN+7*NNOT);}

vec2 mainSynth(float time)
{
    float sL = 0.;
    float sR = 0.;
    float dL = 0.;
    float dR = 0.;

    if (time > SONGLENGTH) return vec2(0.);
    
    int _it;
    for(_it = 0; _it < NTIME - 2 && pos_t[_it + 1] < time; _it++);
    BPS = pos_BPS[_it];
    SPB = pos_SPB[_it];
    BT = pos_B[_it] + (time - pos_t[_it]) * BPS;

    float time2 = time - .0002;
    float sidechain = 1.;

    float amaysynL, amaysynR, amaydrumL, amaydrumR, B, Bon, Boff, Bprog, Bproc, L, tL, _t, _t2, vel, rel, pre, f, amtL, amtR, env, slide, aux;
    int tsep0, tsep1, _modU, _modL, ptn, psep0, psep1, _noteU, _noteL, syn, drum;

    for(int trk = 0; trk < NTRK; trk++)
    {
        tsep0 = trk_sep(trk);
        tsep1 = trk_sep(trk + 1);

        syn = trk_syn(trk);
        rel = trk_rel(trk) + 1.e-3;
        pre = trk_pre(trk);

        for(_modU = tsep0; (_modU < tsep1 - 1) && (BT > mod_on(_modU + 1) - pre); _modU++);
        for(_modL = tsep0; (_modL < tsep1 - 1) && (BT >= mod_off(_modL) + rel); _modL++);

        for(int _mod = _modL; _mod <= _modU; _mod++)
        {
            B = BT - mod_on(_mod) + pre;

            ptn   = mod_ptn(_mod);
            psep0 = ptn_sep(ptn);
            psep1 = ptn_sep(ptn + 1);

            for(_noteU = psep0; (_noteU < psep1 - 1) && (B > note_on(_noteU + 1)); _noteU++);
            for(_noteL = psep0; (_noteL < psep1 - 1) && (B >= note_off(_noteL) + rel); _noteL++);

            for(int _note = _noteL; _note <= _noteU; _note++)
            {
                if(syn == 36)
                {
                    drum = int(note_pitch(_note));
                    rel = drum_rel(drum) + 1.e-3;
                }

                amaysynL  = 0.;
                amaysynR  = 0.;
                amaydrumL = 0.;
                amaydrumR = 0.;

                Bon   = note_on(_note);
                Boff  = note_off(_note) + rel;
                L     = Boff - Bon;
                tL    = L * SPB;
                Bprog = max(0., B - Bon); // I DO NOT GET THIS WEIRD FIX, but Revision is approaching
                Bproc = Bprog / L;
                _t    = Bprog * SPB; 
                _t2   = _t - .0002; // this is on purpose not max(0., _t - .0002), because I hope future-QM is clever
                vel   = note_vel(_note);
                amtL  = clamp(1. - note_pan(_note), 0., 1.);
                amtR  = clamp(1. + note_pan(_note), 0., 1.);
                slide = note_slide(_note);
                aux   = note_aux(_note);

                if(syn == 36)
                {
                    env = trk_norm(trk) * theta(Bprog) * theta(L - Bprog);
                    if(drum == 0) { sidechain = min(sidechain, 1. - vel * (clamp(1.e4 * Bprog,0.,1.) - pow(Bprog/(L-rel),8.)));}
                    
                    if(drum > 0)
                    {
                        dL += amtL * s_moothmin(env * amaydrumL);
                        dR += amtR * s_moothmin(env * amaydrumR);
                    }
                }
                else
                {
                    f = freqC1(note_pitch(_note) + mod_transp(_mod));

                    if(abs(slide) > 1e-3) // THIS IS SLIDEY BIZ
                    {
                        float Bslide = trk_slide(trk);
                        float fac = slide * log(2.)/12.;
                        if (Bprog <= Bslide)
                        {
                            float help = 1. - Bprog/Bslide;
                            f *= Bslide * (fhelp(fac) - help * fhelp(fac*help*help)) / Bprog;
                        }
                        else
                        {
                            f *= 1. + (Bslide * (fhelp(fac)-1.)) / Bprog;
                        }
                    }

                    env = theta(Bprog) * (1. - smstep(Boff-rel, Boff, B));
                    if(syn == 0){amaysynL = _sin(f*_t); amaysynR = _sin(f*_t2);}
                    else if(syn == 29){
                        
                        amaysynL = env_AHDSRexp(Bprog,L,.1+.001*aux,0.,.1,1.,0.)*(.5*sinshape(_tri(f*(_t-0.0*(1.+.1*_sin(.025*SPB*_t)))+.005*aux*env_AHDSRexp(Bprog,L,.125,0.,.1,1.,0.)*(2.*fract(.5*f*(_t-0.0*(1.+.1*_sin(.025*SPB*_t))))-1.)+.01*aux*env_AHDSRexp(Bprog,L,.05+.006*aux,0.,.1,1.,0.)*clip((1.+.8)*(2.*fract(1.51*f*(_t-0.0*(1.+.1*_sin(.025*SPB*_t))))-1.)))+.6*clip((1.+.4)*_sin(.499*f*(_t-0.0*(1.+.1*_sin(.025*SPB*_t))))),.2+.03*aux*vel,3.)
      +.5*sinshape(_tri(f*(_t-1.0e-01*(1.+.1*_sin(.025*SPB*_t)))+.005*aux*env_AHDSRexp(Bprog,L,.125,0.,.1,1.,0.)*(2.*fract(.5*f*(_t-1.0e-01*(1.+.1*_sin(.025*SPB*_t))))-1.)+.01*aux*env_AHDSRexp(Bprog,L,.05+.006*aux,0.,.1,1.,0.)*clip((1.+.8)*(2.*fract(1.51*f*(_t-1.0e-01*(1.+.1*_sin(.025*SPB*_t))))-1.)))+.6*clip((1.+.4)*_sin(.499*f*(_t-1.0e-01*(1.+.1*_sin(.025*SPB*_t))))),.2+.03*aux*vel,3.))
      +.5*sinshape(_tri(f*floor(7888.*_t+.5)/7888.+.005*aux*env_AHDSRexp(Bprog,L,.125,0.,.1,1.,0.)*(2.*fract(.5*f*floor(7888.*_t+.5)/7888.)-1.)+.01*aux*env_AHDSRexp(Bprog,L,.05+.006*aux,0.,.1,1.,0.)*clip((1.+.8)*(2.*fract(1.51*f*floor(7888.*_t+.5)/7888.)-1.)))+.6*clip((1.+.4)*_sin(.499*f*floor(7888.*_t+.5)/7888.)),.2+.03*aux*vel,3.)*env_AHDSRexp(Bprog,L,.1+.001*aux,0.,.1,1.,0.);
                        amaysynR = env_AHDSRexp(Bprog,L,.1+.001*aux,0.,.1,1.,0.)*(.5*sinshape(_tri(f*(_t2-0.0*(1.+.1*_sin(.025*SPB*_t2)))+.005*aux*env_AHDSRexp(Bprog,L,.125,0.,.1,1.,0.)*(2.*fract(.5*f*(_t2-0.0*(1.+.1*_sin(.025*SPB*_t2))))-1.)+.01*aux*env_AHDSRexp(Bprog,L,.05+.006*aux,0.,.1,1.,0.)*clip((1.+.8)*(2.*fract(1.51*f*(_t2-0.0*(1.+.1*_sin(.025*SPB*_t2))))-1.)))+.6*clip((1.+.4)*_sin(.499*f*(_t2-0.0*(1.+.1*_sin(.025*SPB*_t2))))),.2+.03*aux*vel,3.)
      +.5*sinshape(_tri(f*(_t2-1.0e-01*(1.+.1*_sin(.025*SPB*_t2)))+.005*aux*env_AHDSRexp(Bprog,L,.125,0.,.1,1.,0.)*(2.*fract(.5*f*(_t2-1.0e-01*(1.+.1*_sin(.025*SPB*_t2))))-1.)+.01*aux*env_AHDSRexp(Bprog,L,.05+.006*aux,0.,.1,1.,0.)*clip((1.+.8)*(2.*fract(1.51*f*(_t2-1.0e-01*(1.+.1*_sin(.025*SPB*_t2))))-1.)))+.6*clip((1.+.4)*_sin(.499*f*(_t2-1.0e-01*(1.+.1*_sin(.025*SPB*_t2))))),.2+.03*aux*vel,3.))
      +.5*sinshape(_tri(f*floor(7888.*_t2+.5)/7888.+.005*aux*env_AHDSRexp(Bprog,L,.125,0.,.1,1.,0.)*(2.*fract(.5*f*floor(7888.*_t2+.5)/7888.)-1.)+.01*aux*env_AHDSRexp(Bprog,L,.05+.006*aux,0.,.1,1.,0.)*clip((1.+.8)*(2.*fract(1.51*f*floor(7888.*_t2+.5)/7888.)-1.)))+.6*clip((1.+.4)*_sin(.499*f*floor(7888.*_t2+.5)/7888.)),.2+.03*aux*vel,3.)*env_AHDSRexp(Bprog,L,.1+.001*aux,0.,.1,1.,0.);
                    }
                    else if(syn == 35){
                        time2 = time-.003; _t2 = _t-.003;
                        amaysynL = env_AHDSRexp(Bprog,L,.05,0.,.1,.4,.2)*MADD(_t,f,0.,32,1,env_AHDSRexp(Bprog,L,.185,0.,.1,1.,0.)+-1.+.2*env_AHDSRexp(Bprog,L,.05,0.,.1,.4,.2)*(.5+(.5*_sin(10.*Bprog))),bracepad_cutoff(BT)*env_AHDSRexp(Bprog,L,.05,0.,.15,.01,.3),.1,100.,10000.,(.5+(.5*_sin(10.*Bprog)))*env_AHDSRexp(Bprog,L,.185,0.,.1,1.,0.)*(0.075/f),0.,0.,0.)
      +bracepad_sub(BT)*env_AHDSRexp(Bprog,L,.05,0.,.1,.4,.2)*_sin_(.5*f*_t,.4*(.5+(.5*_sin(10.*Bprog))));
                        amaysynR = env_AHDSRexp(Bprog,L,.05,0.,.1,.4,.2)*MADD(_t2,f,0.,32,1,env_AHDSRexp(Bprog,L,.185,0.,.1,1.,0.)+-1.+.2*env_AHDSRexp(Bprog,L,.05,0.,.1,.4,.2)*(.5+(.5*_sin(10.*Bprog))),bracepad_cutoff(BT)*env_AHDSRexp(Bprog,L,.05,0.,.15,.01,.3),.1,100.,10000.,(.5+(.5*_sin(10.*Bprog)))*env_AHDSRexp(Bprog,L,.185,0.,.1,1.,0.)*(0.075/f),0.,0.,0.)
      +bracepad_sub(BT)*env_AHDSRexp(Bprog,L,.05,0.,.1,.4,.2)*_sin_(.5*f*_t2,.4*(.5+(.5*_sin(10.*Bprog))));
                    }
                    
                    sL += amtL * trk_norm(trk) * s_moothmin(clamp(env,0.,1.) * amaysynL);
                    sR += amtR * trk_norm(trk) * s_moothmin(clamp(env,0.,1.) * amaysynR);
                }
            }
            
        }
    }
    float masterL = .15 * sidechain * sL + .67 * dL;
    float masterR = .15 * sidechain * sR + .67 * dR;
    return vec2(
        masterL,
        masterR);
}

void main()
{
    Tsample = 1./iSampleRate;
    float t = (iBlockOffset + gl_FragCoord.x + gl_FragCoord.y*iTexSize) * Tsample;
    vec2 s = mainSynth(t);
    vec2 v  = floor((0.5+0.5*s)*65535.0);
    vec2 vl = mod(v,256.0)/255.0;
    vec2 vh = floor(v/256.0)/255.0;
    gl_FragColor = vec4(vl.x,vh.x,vl.y,vh.y);
}
